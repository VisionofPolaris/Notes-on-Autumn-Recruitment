# 滑动窗口

# 基础知识

## 一般要求

- 求连续子数组，长度可以固定也可以不固定，一般是求最长/最短子数组。

## 基本逻辑

- 固定右边界R，当不满足某种条件时，左边界L收缩。
- 遍历数组的下标i，根据需求调整右边界R的位置。

![9c3cbd5459204b739929329c73a47523.png](%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%201ea2544d14f94ad5bec4a585f3a984dc/9c3cbd5459204b739929329c73a47523.png)

# 习题

## Case1 更新左边界

### 904-水果成篮

给定一个数组，输出连续的、只包含2种元素的**连续子数组**的**最大长度**。

- 用HashMap统计区间中元素的个数，某个元素个数为0时从Map中移除；
- 右指针右移，当Map中元素个数大于2时，左指针右移直到元素个数等于2；
- 右指针每右移一次，更新Map之后，计算R-L+1，更新最大区间长度。

### 713-乘积小于K的子数组

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回子数组内所有元素的乘积严格小于 **`k` 的连续**连续子数组**的**数目**。

- 右指针每次右移，移动左指针直到区间内乘积小于K；
- 以右指针所在位置为结尾的子数组个数为R-L+1，累加即可。

### 1004-最大连续1的个数Ⅲ

给定一个二进制数组 `nums` 和一个整数 `k`，如果可以翻转最多 `k` 个 `0` ，则返回**数组中连续** `1` 的**最大个数** 。

- 右指针每次右移，当窗口内0的个数大于k时，移动左指针到窗口内第一个0的下一位（用队列记录0的序号）。
- 每次左值针移动之前记录窗口的最大长度，当遍历完之后也要记录一次。

### 209-长度最小的子数组

给定一个含有 `n` ****个正整数的数组和一个正整数 `target` **。**找出该数组中满足其总和大于等于 ****`target` ****的**长度最小**的**子数组**[numsl, numsl+1, ..., numsr-1, numsr]，并返回其长度**。**如果不存在符合条件的子数组，返回0。

- 右指针每次右移，直到窗口内和大于等于target，左指针开始收缩直到小于target，记录一次长度（R-L+2）。

### 3-无重复最长子串

给定一个字符串s，请你找出其中不含有重复字符的**最长 子串**的长度。

- 右指针每次右移，直到窗口内有两个重复的字符，记录字符串的长度，左边界移动到前一个重复字符的下一位。
- 用哈希表记录重复字符和位置的序号。

## Case 2 更新右边界

### 763-划分字母区间

给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。

返回一个表示每个字符串片段的长度的列表。

```
输入：s = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca"、"defegde"、"hijhklij" 。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。
```

- 用HashMap统计字符出现的最远的位置；
- 遍历字符数组，每遍历一个字符，获取该字符出现的最远位置，如果比右边界R大，更新R。如果遍历位i等于右边界R，获取答案（R-L+1），更新左边界L=R+1。

## Case3 固定窗口

### 567-字符串的排列

给你两个字符串 `s1` 和 `s2` ，写一个函数来判断 `s2` 是否包含 `s1` ****的排列。如果是，返回 `true` ；否则，返回 `false` 。换句话说，`s1` 的排列之一是 `s2` 的 **子串** 。

- 用HashMap统计s1中各个字符的个数。
- 用HashMap统计s2固定窗口中字符的个数，左右指针每移动一次更新map，如果equals前一个HashMap则返回True。

### 438-找到字符串中所有字母异位词

跟567题一样。