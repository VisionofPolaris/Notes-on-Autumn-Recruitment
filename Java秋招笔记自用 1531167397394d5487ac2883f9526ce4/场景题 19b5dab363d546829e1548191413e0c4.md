# 场景题

# 缓存

## 设计一个缓存策略动态缓存热点数据

- 背景：由于数据系统受限，只将一部分热点数据缓存起来。
- 思路：通过数据最新访问时间来排名，并过滤掉补偿访问的数据，只留下经常访问的数据。
- 案例：缓存用户经常访问的TOP1000商品。
    - 先通过缓存系统做一个排序队列（存放1000个商品），根据访问的时间更新队列信息，越近访问的商品排名越靠前；
    - 定期过滤队列中排名最后的200个商品，再从数据库中随机读出200个商品加入队列中；
    - 请求每次到达时，会先从队列中获取商品ID，如果命中，就根据ID再从缓存数据结构中读取实际的商品信息。

# 商城

## 订单未支付过期如何实现自动关闭订单？

- 定时任务：设定定时任务，定期扫描数据库中的订单，如果时间过期就将其状态更新为关闭。（时间不够精确，增加了对数据库的压力）
- Redis提供过期监听功能。
- RabbitMQ死信交换机。将目标队列绑定一个死信交换机，给消息设置过期时间，消息过期后会投递到死信交换机，消费者从死信交换机中获取数据。

## 秒杀系统

秒杀系统业务逻辑简单，无非就是下单减库存，但需要满足以下条件：

- 高并发：能同时处理很多用户请求；
- 高性能：处理用户请求要快；
- 高可用：在趋近100%的时间内都能提供正确的服务。

### 【高并发&高性能】热点数据处理

1. 怎么找到热点数据并存在JVM内存里？通过一些中间件如京东hotkey来检测热点数据，毫秒级探测热点数据并推送至服务器集群内存。
2. 热点数据怎么处理？一定要放在缓存中，最好能写入到jvm内存中，并设置过期时间，在JVM中数据访问速度是最快的，不存在什么网络开销。

### 【高并发&高性能】流量削峰

1. 秒杀开始后的流量很大，为了避免打垮后端服务，将请求放入消息队列，根据服务器的能力慢慢消化。
2. 让用户在发起请求之前进行答题或输入验证码，避免用户使用脚本作弊或避免请求过于集中。

### 【高可用】集群化

Redis集群，哨兵模式。

### 【高可用】限流

接口每秒种只能处理10w个请求，活动开始来了15w，需要将5w个请求拦截防止系统挂掉，可以用开源的流量控制组件。

1. 当请求量达到一个阈值的时候，我们就通知用户让它们排队。等到系统可以继续处理请
求之后，再慢慢来处理。
2. 降级：当请求量达到一个阈值的时候，我们对系统中一些非核心的功能直接关闭或者让它们功能降低。这样的话，系统就有更多的资源留给秒杀功能了！
3. 熔断：秒杀功能位于服务 A 上，服务 A 上同时还有其他的一些功能比如商品管理。如果服务 A上的商品管理接口响应非常慢的话，其他服务直接不再请求服务 A 上的商品管理这个接口，从而有效避免其他服务被拖慢甚至拖死。熔断可以防止因为秒杀交易影响到其他正常服务的提供。

### 【高可用】一致性

1. 减库存方案：
    1. 下单即使不付款也会减库存；
    2. 超卖：会将秒杀商品的信息放到缓存里去，通过Redis对库存进行原子操作，先检查库存是否充足，如果库存充足，则减少库存。也可以通过Lua脚本减少多个命令的网络开销保证多个命令整体的原子性。
2. 接口幂等：不论执行多少次相同的请求，产生的效果和返回的结果都和发出单个请求是一样的。假如咱们的前后端没有保证接口幂等性，我作为用户在秒杀商品的时候，我同时点击了多次秒杀商品按钮，后端处理了多次相同的订单请求，结果导致一个人秒杀了多个商品。
    1. 前端：用户提交请求后按钮变灰；
    2. 后端：（1）索引唯一约束，防止订单数据重复产生；（2）分布式锁；（3）……

## 如何设计一个排行榜？

1. MySQL的Order by；
    1. 优点：简单，不需要引入其他组件；缺点：耗时，数据量一大，对数据库性能消耗大。
    2. 优化：对排序字段加索引，限制排序数量。
2. Redis的ZSet：
    1. Redis只保存了排行榜展示所需要的数据，需要用户具体的数据还是要从对应的数据库查。

# 海量数据处理

## 位图

### 100亿个整数找到只出现一次的整数？

一个数的出现只有三种情况：出现0次、出现一次、出现一次以上。

改进位图，用两位表示一个数，01代表出现一次的数。一个位图512M大小。

### 两个文件分别有100亿整数，只有1G内存，找到文件交集？

依次读取第一个文件中的所有整数，将其映射到一个位图。

再读取另一个文件中的所有整数，判断在不在位图中，在就是交集，不在就不是交集。

### 一个文件有100亿整数，1G内存找到不超过2次的数？

类似第一题，四个状态两个位图解决。

## 布隆过滤器

## 哈希切割

### 两个文件，分别有100亿个query，只有1G内存，找到两个文件交集？

- 将一个文件切分成小文件，假设每个文件512M，计算出切分文件的个数（用于哈希）。用同一个哈希函数切分，假如A文件且成A0~A99，B文件且成B0~B99，则，A0和B0计算交集，以此类推。
- 小文件找交集时，如果有文件大小小于1G，则加载到内存set容器，再遍历另一个文件判断是否在set容器中。如果两个文件都大于1G再重新切分。

## 排序

### 20G的int类型数据，计算机内存只有2G怎么排序？

分治法：

1. 将文件分成多份，每一份可以装进内存；
2. 对多分文件分别进行排序；
3. 采用n路归并排序，每次对n组数据进行排序（取n组中最小的数据并输出）。

### TOP K问题

1. 在数据量较少的情况下直接排序。
2. 快速排序变形：在内存够用的情况下采用特殊的快速排序：
    1. 传统的快排每次递归找到一个元素为枢轴，将大于枢轴和小于枢轴的数分别放在一边。
    2. 如果划分的枢轴索引正好等于K那么直接返回这个划分元以及其左边的数；如果K小于索引则对左边递归，否则对右边递归。
3. 小根堆：取K个数建立一个小根堆，将剩余的所有数字依次与小根堆顶进行比较，如果比堆顶元素大，则删除堆顶元素，并将数据插入调整小根堆。
4. 分治法：将数据分成n份，每一份可以读到内存中处理排序，再取出前n*K个数据再次排序。