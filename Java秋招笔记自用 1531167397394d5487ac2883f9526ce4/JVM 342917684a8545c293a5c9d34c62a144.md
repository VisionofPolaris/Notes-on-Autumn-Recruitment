# JVM

# 运行时数据区

![java-runtime-data-areas-jdk1.7.png](JVM%20342917684a8545c293a5c9d34c62a144/java-runtime-data-areas-jdk1.7.png)

![java-runtime-data-areas-jdk1.8.png](JVM%20342917684a8545c293a5c9d34c62a144/java-runtime-data-areas-jdk1.8.png)

运行时数据区包括：线程公有的部分和线程私有的部分。

## 线程私有区

### 程序计数器

- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的**流程控制**，如：顺序执行、选择、循环、异常处理。
- 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

唯一一个不会OOM的区域。

### Java虚拟机栈

方法调用时会将栈帧压入栈中，方法调用结束栈帧会弹出。

- 局部变量表：存放编译期可知的各种数据类型和对象引用。
- 操作数栈：存放方法执行过程中产生的中间计算结果或临时变量。
- 动态链接：当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用。

![stack-area.png](JVM%20342917684a8545c293a5c9d34c62a144/stack-area.png)

Java虚拟机栈会有两种错误：

- `StackOverflowError`：线程请求的栈的深度大于虚拟机所允许的深度（方法递归调用）；
- `OutOfMemoryError`：虚拟机栈扩展时无法申请到足够的内存（创建很多线程把内存占满）。

### 本地方法栈

和虚拟机栈所发挥的作用非常相似，虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。

## 线程公有区

### 堆

![hotspot-heap-structure.png](JVM%20342917684a8545c293a5c9d34c62a144/hotspot-heap-structure.png)

- 此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。
- 堆是垃圾收集器管理的主要区域，因此也被称作 **GC 堆（Garbage Collected Heap）**。
- 堆包括：
    - 新生代：伊甸区和两个幸存者区。对象首先在伊甸区分配内存，在一次垃圾回收后如果还存活进入幸存者区（S0或S1）。当年龄增加到设定值（默认15岁），进入老年代。记录年龄的区域在对象头中，通常是4位，可以表示最大的数字是15，所以设定值不能超过15
    - 老年代
    - 永久代，1.8版本后被元空间取代

堆这里最容易出现的就是 `OutOfMemoryError` 错误，如创建新的对象时，堆内存中的空间不足以存放新创建的对象，就会引发此错误。

### 方法区

方法区是JVM定义的一种规范，永久代和元数据都是某个虚拟机针对“方法区”的一种实现，类似于接口和类的关系。

当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的**类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据**。

JDK1.8，永久代被永远移除，被元空间取代，元空间使用本地内存。

### 运行时常量池

用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）。

- 符号引用：用一组符号来无歧义定位到目标，如类的全限定名、方法名和描述符、字段名和描述符。
- 直接引用：可以直接指向目标的指针、相对偏移量或能间接定位到目标的句柄。

### 字符串常量池

为了提升性能和减少内存消耗针对字符串（String）专门开辟的一块区域，避免字符串的重复创建。

JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。主要由于永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。

# 垃圾回收

## 垃圾回收的区域

部分收集 (Partial GC)：

- 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
- 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

整堆收集 (Full GC)：收集整个 Java 堆和方法区。

## 内存分配和垃圾回收过程

1. 对象优先在Eden区分配，当Eden区没有足够空间时，虚拟机发起一次Minor GC。
2. 大对象直接进入老年代，减少新生代垃圾回收的频率和成本。
3. 如果对象在Eden区出生并且经过第一次Minor GC后仍然可以存活，且能够被survivor容纳，则会移动到survivor区，并将年龄设为1。如果不能被survivor容纳，则通过**分配担保机制**直接提前转移到老年代区。
4. 对象在 Survivor 中每熬过一次 MinorGC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。

## 垃圾对象

### 判断对象死亡的两种方法？

1. 引用计数法：给对象中添加一个引用计数器：每当有一个地方引用他，计数器加1，每当引用失效，计数器减1。计数器为0的对象就是不可能再被使用的。主流的虚拟机没有使用这种方法，很难解决对象之间的循环依赖问题。
2. 可达性分析算法：通过一系列的称为**“GC Roots”**的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要经过两次标记后被回收。
    
    可以作为GC Roots的对象：
    
    - 虚拟机栈（栈帧中的局部变量表）中引用的对象
    - 本地方法栈（Native 方法）中引用的对象
    - 方法区中类静态属性引用的对象
    - 方法区中常量引用的对象
    - 所有被同步锁持有的对象
    - JNI（Java Native Interface）引用的对象

### 引用类型有哪些？

1. 强引用（StrongReference）：如果一个对象具有强引用，那就类似于**必不可少的生活用品**，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出OutOfMemoryError 错误，使程序异常终止。
2. 软引用（SoftReference）：如果一个对象只具有软引用，那就类似于**可有可无的生活用品**。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。
3. 弱引用（WeakReference）：如果一个对象只具有弱引用，那就类似于**可有可无的生活用品**。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。
4. 虚引用（PhantomReference）：如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。

### 如何判断一个常量是废弃的常量？

假如在字符串常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了。

### 如何判断一个类是无用的类？

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 `ClassLoader` 已经被回收。
- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

## 垃圾收集算法

### 标记-清除算法

标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。

1. **效率问题**：标记和清除两个过程效率都不高。
2. **空间问题**：标记清除后会产生大量不连续的内存碎片。

### 复制算法

它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。

- **可用内存变小**：可用内存缩小为原来的一半。
- **不适合老年代**：如果存活对象数量比较大，复制性能会变得很差。

### 标记-整理算法

标记-整理（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

效率也不高，适合老年代这种垃圾回收频率不是很高的场景。

### 分代收集算法

当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。

# 类加载与卸载

类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，验证、准备和解析这三个阶段可以统称为连接（Linking）。

![lifecycle-of-a-class.png](JVM%20342917684a8545c293a5c9d34c62a144/lifecycle-of-a-class.png)

## 类加载

1. 加载：获取定义此类的二进制字节流，并将字节流所代表的静态存储结构转化为方法区的运行时数据结构，在内存中生成一个代表该类的 `Class` 对象。
2. 连接：加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。
    1. 验证：是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。包括：文件格式验证、元数据验证、字节码验证、符号引用验证。
    2. 准备：**准备阶段是正式为类变量分配内存并设置类变量初始值的阶段**，这些内存都将在方法区中分配。
    3. 解析：解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
3. 初始化：判断代码中是否存在主动的资源初始化动作（成员变量的赋值、静态变量的赋值、静态代码块等），如果有就执行。

## 类卸载

卸载类需要满足 3 个要求:

1. 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象
2. 该类没有在其他任何地方被引用
3. 该类的类加载器的实例已被 GC

## 类加载器

### 加载规则

- 类加载器的主要作用就是加载 Java 类的字节码（ `.class` 文件）到 JVM 中（在内存中生成一个代表该类的 `Class` 对象）。
- 类加载器在JVM启动时不会一次性加载所有的类，而是根据需要去动态加载。
- 已经加载的类会被放在 `ClassLoader` 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。

### 类加载器类型

- **`BootstrapClassLoader`(启动类加载器)**：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ `%JAVA_HOME%/lib`目录下的 `rt.jar`、`resources.jar`、`charsets.jar`等 jar 包和类）以及被 `Xbootclasspath`参数指定的路径下的所有类。
- **`ExtensionClassLoader`(扩展类加载器)**：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。
- **`AppClassLoader`(应用程序类加载器)**：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

![class-loader-parents-delegation-model.png](JVM%20342917684a8545c293a5c9d34c62a144/class-loader-parents-delegation-model.png)

### 双亲委派机制

- 在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。
- 类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 `loadClass()`方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 `BootstrapClassLoader` 中。
- 只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 `findClass()` 方法来加载类）。
- 如果子类加载器也无法加载这个类，那么它会抛出一个 `ClassNotFoundException` 异常

双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。

自定义加载器的话，需要继承ClassLoader。如果我们不想打破双亲委派模型，就重写ClassLoader类中的findClass()方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写loadClass()方法。

# JVM问题排查

对于正在运行的系统，可以通过一些命令来监控：

1. 可以通过jmap查看JVM各个区域的使用情况；
2. 可以通过jstack查看线程的运行情况，如线程是否发生了阻塞或死锁；
3. 可以通过jstat查看垃圾回收的情况，特别是full gc，如果full gc较频繁，就需要调优了。

如果出现问题的话，就需要分析原因。例如，频繁发生fullGC却又没有内存溢出，需要考虑是否是对象比较大，导致年轻代放不下直接进入老年代。可以尝试加大年轻代的大小。

对于已经发生了OOM的系统，通过一些分析工具来分析dump文件，根据dump文件找到异常的实例对象和异常的线程，定位到具体的代码进行分析和调试。