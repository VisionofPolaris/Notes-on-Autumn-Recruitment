# 位运算

# 位运算

## 基本位运算

| 符号 | 描述 | 运算规则 |
| --- | --- | --- |
| & | 与 | 两个位都为1时，结果才为1 |
| | | 或 | 两个位都为0时，结果才为0 |
| ^ | 异或 | 两个位相同为0，不同为1 |
| ~ | 取反 | 所有位置0变1，1变0 |
| << | 左移 | 各二进位全部左移若干位，高位丢弃，低位补0 |
| >> | 带符号右移 | 各二进位全部右移若干位，低位丢弃，高位补为符号位 |
| >>> | 无符号右移 | 各二进位全部右移若干位，低位丢弃，高位补0 |

## 性质

1. 正数
    1. 右移n位相当于除以2的n次方（只取整数部分）。
    2. 左移n位相当于乘以2的n次方。
2. `n & (n-1)`：去除最低为1的一位；`n & (-n)`：得到最低为1的一位。
3. $(a \oplus a) \oplus (b \oplus b) \oplus ... \oplus n=n$
4. 补位
    1. 右移：最高位是1，补1；最高位是0，补0；
    2. 左移：补0。
5. 取出最低位：n & 1。

## 应用

- 找出出现一次的数：
    - 一个数只出现1次，其他数出现2次（性质3）
    - 一个数只出现1次，其他数出现3次（按位统计模3）
    - 两个数出现1次，其他数出现2次（性质3，分组异或）
- 找出数组中重复出现的数：
    - 数组长度为n、数字范围[1, n]的数组中找出重复的数字（交换位置）
- 找出数组中缺失的数：
    - 范围[0, n]，长度是n的数组缺失1个数（性质3）
    - 范围[0, n]，长度是n的数组缺失2个数（性质3，分组异或）
    - 范围[0, n]，长度是n的数组缺失n个数（交换位置）

解题思路总结：

1. 利用异或的性质；
2. 二进制按位统计；
3. 哈希集合；
4. 交换位置。

# 习题

## 基本性质

### 231-2的幂

判断一个数是否是2的幂：`return n > 0 && n & (n -1) == 0;`

### 477-汉明距离总和

两个整数的 [汉明距离](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/475174?fr=aladdin) 指的是这两个数字的二进制数对应位不同的数量。给你一个整数数组 `nums`，请你计算并返回 `nums` 中任意两个数之间 **汉明距离的总和** 。

依次计算每一个位1和0的个数分别为n，m，该位的汉明距离的总和为$n \times m$。累加即可。

![44c58bd38dc643fc85593d29050a6554.png](%E4%BD%8D%E8%BF%90%E7%AE%97%20b39fd6f1702f4944817493ee9559cb87/44c58bd38dc643fc85593d29050a6554.png)

### 201-数字范围按位与

【位运算】

给你两个整数 `left` 和 `right` ，表示区间 `[left, right]` ，返回此区间内所有数字 **按位与** 的结果（包含 `left` 、`right` 端点）。

分析：

- 只看最低位，如果left比right小，最低位就为0。（最低位0101……循环）
- 一直右移到两个数相等，再左移相同的位数得到结果。

```java
public int rangeBitwiseAnd(int left, int right) {
    int offset = 0;
    while (left != right) {
        left = left >> 1;
        right = right >> 1;
        offset++;
    }
    return left << offset;
}
```

## 应用1【消失的数】

### 268-丢失的数字

给定一个包含 `[0, n]` 中 `n` 个数的数组 `nums` ，找出 `[0, n]` 这个范围内没有出现在数组中的那个数。

将给定数组和[0, n]中的所有的数异或一遍，转化为问题136。

```java
public int missingNumber(int[] nums) {
    int ans = 0;
    for (int n: nums) {
        ans ^= n;
    }
    for (int i = 0; i <= nums.length; i++) {
        ans ^= i;
    }
    return ans;
}
```

### 17.19-消失的两个数字

转化为问题260。

### 41-缺失的第一个正数

【哈希集合】

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。请你实现时间复杂度为并且只使用常数级别额外空间`O(n)`的解决方案。

- 一次遍历将数字存入哈希集合中；
- 再从最小的正数遍历起，如果不在哈希集合中则返回。

### 448-找到所有数组中消失的数字

【位置交换】

给你一个含 `n` 个整数的数组 `nums` ，其中 `nums[i]` 在区间 `[1, n]` 内。请你找出所有在 `[1, n]` 范围内但没有出现在 `nums` 中的数字，并以数组的形式返回结果。

![1613179207-JrWzql-image.png](%E4%BD%8D%E8%BF%90%E7%AE%97%20b39fd6f1702f4944817493ee9559cb87/1613179207-JrWzql-image.png)

两次遍历数组，第一次让每一个数字交换去理应出现的位置；再一次遍历，如果当前位置序号+1不是数组中的数字则为缺失数字。

```java
public void swap(int[] nums, int a, int b) {
    int t = nums[b];
    nums[b] = nums[a];
    nums[a] = t;
}

public List<Integer> findDisappearedNumbers(int[] nums) {
    List<Integer> ans = new ArrayList<>();

    int i = 0;
    while (i < nums.length) {
        if (nums[i] != i+1 && nums[nums[i]-1] != nums[i]) {
            swap(nums, i, nums[i]-1);
        }
        else {
            i++;
        }
    }

    for (int j = 0; j < nums.length; j++) {
        if (nums[j] != j + 1) {
            ans.add(j + 1);
        }
    }

    return ans;
}
```

## 应用2【重复出现的数】

### 442-数组中重复的数据

【位置交换】

给你一个长度为 `n` 的整数数组 `nums` ，其中 `nums` 的所有整数都在范围 `[1, n]` 内，且每个整数出现 **一次** 或 **两次** 。请你找出所有出现 **两次** 的整数，并以数组形式返回。

同448

### 287-寻找重复数

【二进制按位统计】

给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。

- 按位统计nums数组中每个二进制位的1的个数，记为x；
- 按位统计1-n每个数二进制位的1的个数，记为y；
- 如果x>y，ans对应的二进制位为1。

证明：

考虑不同示例数组中第 i 位 1 的个数 x 的变化：

- 如果测试用例的数组中 target 出现了两次，其余的数各出现了一次，且 target 的第 i 位为 1，那么 nums 数组中第 i 位 1 的个数 x 恰好比 y 大一。如果target 的第 i 位为 0，那么两者相等。
- 如果测试用例的数组中 target 出现了三次及以上，那么必然有一些数不在 nums 数组中了，这个时候相当于我们用 target 去替换了这些数，我们考虑替换的时候对 x 的影响：
    - 如果被替换的数第 i 位为 1，且 target 第 i 位为 1：x 不变，满足 x>y。
    - 如果被替换的数第 i 位为 0，且 target 第 i 位为 1：x 加一，满足 x>y。
    - 如果被替换的数第 i 位为 1，且 target 第 i 位为 0：x 减一，满足 x≤y。
    - 如果被替换的数第 i 位为 0，且 target 第 i 位为 0：x 不变，满足 x≤y。
    
    也就是说如果 target 第 i 位为 1，那么每次替换后只会使 x 不变或增大，如果为 0，只会使 x 不变或减小，始终满足 x>y 时 target 第 i 位为 1，否则为 0，因此我们只要按位还原这个重复的数即可。
    

```java
public int findDuplicate(int[] nums) {
    int ans = 0;
    for (int i = 0; i <= 30; i++) {
        int x = 0;
        int y = 0;

        for (int n: nums) {
            if ((n >> i & 1) == 1) {
                x++;
            }
        }
        for (int j = 1; j < nums.length; j++) {
            if ((j >> i & 1) == 1) {
                y++;
            }
        }

        if (x > y) {
            ans |= (1 << i);
        }
    }

    return ans;
}
```

## 应用3【只出现x次的数】

### 136-只出现一次的数字

给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

性质：$(a \oplus a) \oplus (b \oplus b) \oplus ... \oplus n=n$

### 389-找不同

- 同136，字符也可以作为整数参与表达式计算
- int转对应的ASCII码字符直接强制类型转换即可

### 260-只出现一次的数字Ⅲ

**【位运算或哈希表】**

给你一个整数数组 `nums`，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 **任意顺序** 返回答案。你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。

根据136得到$x=x_a \oplus x_b$，由于$x_a \neq x_b$，$x$必有一位为1。

- 取出最低位的1：$x·(-x)$；
- 按最低位1所在的位置，将所有的数分为两组，$x_a$和$x_b$被分到两组中；
- 每一组分别异或得到两个值。

```java
public int[] singleNumber(int[] nums) {
    int x = 0;
    for (int n: nums) {
        x ^= n;
    }

    int l = x & (-x);
    int xa = 0;
    int xb = 0;
    for(int n: nums) {
        if ((n & l) == 0) {
            xa ^= n;
        }
        else {
            xb ^= n;
        }
    }

    return new int[]{xa, xb};
}
```

### 137-**只出现一次的数字Ⅱ**

**【位运算或哈希表】**

给你一个整数数组 `nums` ，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。

![28f2379be5beccb877c8f1586d8673a256594e0fc45422b03773b8d4c8418825-Picture1.png](%E4%BD%8D%E8%BF%90%E7%AE%97%20b39fd6f1702f4944817493ee9559cb87/28f2379be5beccb877c8f1586d8673a256594e0fc45422b03773b8d4c8418825-Picture1.png)

下面用状态机解决：

由于模3，每一位有三种状态，0-1-2，用两位二进制数表示，输入一位，画真值表，转化为逻辑表达式。

```java
public int singleNumber(int[] nums) {
    int a = 0;
    int b = 0;

    for (int n: nums) {
        int tmpa = a;
        a = (a & ~b & ~n) | (~a & b & n);
        b = ~tmpa & (b ^ n);
    }
		// a一定为0
    return b;
}
```