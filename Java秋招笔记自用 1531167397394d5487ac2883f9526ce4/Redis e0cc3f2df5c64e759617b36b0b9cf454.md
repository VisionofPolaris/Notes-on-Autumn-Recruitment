# Redis

# 缓存

## 缓存的作用

1. 访问速度快；
2. 提高并发量；
3. 降低数据库的压力。

## 本地缓存

### 有哪些本地缓存？

- HashMap/ConcurrentHashMap：只提供了缓存的基本功能，没有过期时间、淘汰策略、命中率统计等功能；
- Guava Cache、Sping Cache；
- Caffeine：性能优秀、使用简单；

### 本地缓存的缺点？

1. 与本地应用耦合，对分布式架构支持不友好，服务器之间缓存无法共享；
2. 本地缓存受到服务部署所在的机器限制明显，当前系统服务所耗费的内存多，那么本地缓存可用的容量就很少。

## 【缓存更新策略】旁路缓存Cache Aside Pattern

### 读写的流程？

- 写操作：
    - 更新DB；
    - 直接删除Cache。
- 读操作：
    - 从Cache中读数据，读到就返回；
    - 读不到从DB中读，并把数据写回Cache中。

### 为什么不更新Cache？

1. 避免对服务端资源造成浪费，直接删除更加直接，频繁更新的数据可能都没有访问到。
2. 并发场景下，更新Cache产生数据不一致问题的概率更大。

### 可以先删除Cache后更新DB吗？

不可以。可能删除Cache之后，有其他的请求将读取的原数据存入了Cache，导致Cache中依然存放旧值，导致数据不一致。解决方法是“延迟双删”。

**先更新DB再删除Cahce也会有缓存不一致的问题**，但缓存中写值比DB中快，所以发生数据不一致的问题概率小。

### 旁路缓存的缺点？

1. 首次请求数据一定不在Cache中，可以将热点数据提前放在Cache中。
2. 写操作频繁的话数据频繁删除，会影响缓存命中率。

## 【缓存更新策略】读写穿透Read/Write Through Patten

将Cache视为主要的数据存储器，从中读取数据并写入数据，Cache负责将数据读取和写入DB。Redis没有提供写入DB的功能，所以很少见。

### 读写的流程？

- 写操作：
    - 先查Cahce，如果Cahce中不存在则更新DB；
    - 如果Cahce中存在直接更新Cache，由Cache写入DB。
- 读操作：
    - 从Cache中读数据，读到就返回；
    - 读不到从DB中把数据放回Cache中，然后返回。

### 读写穿透的缺点？

首次请求数据一定不在Cache中，可以将热点数据提前放在Cache中。

## 【缓存更新策略】异步缓存写入Write Behind Patten

Read/Write Through 是同步更新 cache 和 db，而 Write Behind 则是
只更新缓存，不直接更新 db，而是改为**异步批量的方式来更新 db**。对数据一致性带来了更大的挑战。适合数据一致性要求不高数据又经常变化的场景：浏览量、点赞量等。

MySQL中InnoDB Buffer Pool用到了这种策略。

## 【缓存异常】缓存雪崩

### 什么是缓存雪崩？

大量缓存同时过期或者Redis故障宕机，导致大量请求直接访问数据库，数据库压力骤增，造成数据库宕机。

### 如何解决缓存雪崩问题？

1. 针对大量数据同时过期问题：
    1. **均匀设置过期时间**，例如给数据过期时间加上一个随机数；
    2. **互斥锁**，保证同一时间只有一个请求构建缓存；
    3. **后台更新缓存**，不设置有效期，通过后台服务来更新数据，如有缓存失效，通过消息队列通知后台线程更新缓存。
2. 针对故障宕机问题：
    1. 构建可靠集群；
    2. 服务熔断（暂停业务）或请求限流。

## 【缓存异常】缓存击穿

### 什么是缓存击穿？

热点数据过期，大量请求访问该热点数据，直接访问数据库。

### 如何解决缓存击穿问题？

1. **互斥锁**，保证同一时间只有一个请求构建缓存；

与缓存雪崩类似：

1. **后台更新缓存**，不设置有效期，如果有缓存失效，通过消息队列通知后台线程更新缓存。

## 【缓存异常】缓存穿透

### 什么是缓存穿透？

用户访问的数据既不在缓存中，也不在数据库中，导致大量请求访问数据库。

### 什么情况下会发生缓存穿透？

- 黑客攻击，故意大量访问不存在的数据；
- 业务误操作，将缓存和数据库中的数据删除了。

### 如何解决缓存穿透？

1. 对非法请求进行限制，判断请求参数是否有非法值、请求字段是否存在等。
2. 缓存空值或默认值。
3. 通过布隆过滤器来判断数据是否存在，避免查询数据库。

### 布隆过滤器？

在海量的数据中查找元素是否存在。

- 两个条件：
    - 适用于不需要执行删除操作的结构。
    - 用一定的失误换取空间大大节省，会产生的错误类型：不在表中的数据被判为在表中，该错误无法避免，但可以被压得很低。
- 执行过程：
    - 初始化：新建一个长度为m的二进制数组，设计k个独立的哈希函数。
    - 添加：对于每一条数据，分别经过k个哈希函数和模m的操作，映射成0~m-1的值，再把二进制数组的对应位置改成1。
    - 查询：对于一个陌生数据，同样经过哈希函数和模，如果二进制数组的对应位置均为1，则视为命中。
- 参数设置：已知：样本量$n$和失误率$p$（不需要知道样本的大小）。
    - 确定布隆过滤器的位数：$m=-\frac{n\times \ln p}{(\ln 2)^2}$
    - 确定哈希函数的个数：$k=\ln 2 \times \frac{m}{n}$
    - 实际失误率：$P_真=(1-e^{\frac{n\times k_真}{m_真}})^{k_真}$

## 【缓存一致性】

Redis采用旁路缓存策略，一般先更新DB再删除缓存，为了防止删除缓存出现错误，导致数据不一致，可以通过以下两种方式：

- 消息队列重试机制：将需要删除的数据插入消息队列，由消费者来操作数据。根据[消息队列重试机制](%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%20aab1b797ab0d43b69fd243c898253f9a.md)确保删除。
- 中间件Canal订阅MySQL的binlog+消息队列，规避业务代码侵入的问题。

# 数据类型

## 基本-String

最基本的key-value结构，value不仅可以是字符串，也可以是数字（整数和浮点数）。

### 数据结构

1. **String底层的数据结构是什么？**int和简单动态字符串（SDS）
2. **SDS与C语言原生的字符串有什么区别？**
    1. SDS不仅可以保存文本数据，还可以保存二进制数据（图片、音频、视频、压缩文件等）；
    2. SDS获取字符串长度的时间复杂度是O(1)，其用len属性记录了字符串的长度；
    3. SDS的API是安全的，拼接字符串之前会检查空间是否满足要求，空间不够会自动扩容，不会造成缓冲区溢出。
3. **字符串对象的内部编码有哪些？**
    1. int：如果一个字符串对象保存的是整数值，并且这个整数值可以用`long`类型来表示，那么字符串对象会将整数值保存在字符串对象结构的`ptr`属性里面（将`void*`转换成 long），并将字符串对象的编码设置为`int`。
        
        ![int.webp](Redis%20e0cc3f2df5c64e759617b36b0b9cf454/int.webp)
        
    2. embstr：如果字符串对象保存的是一个字符串，并且这个字符串的长度小于等于X 字节（不同版本不一样），字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为`embstr`， `embstr`编码是专门用于保存短字符串的一种优化编码方式。
        
        ![embstr.webp](Redis%20e0cc3f2df5c64e759617b36b0b9cf454/embstr.webp)
        
    3. raw：如果字符串对象保存的是一个字符串，并且这个字符串的长度大于 X字节（不同版本不一样），那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为`raw` 。
        
        ![raw.webp](Redis%20e0cc3f2df5c64e759617b36b0b9cf454/raw.webp)
        
4. **embstr相对于raw编码的对比？**
    1.  `embstr`编码将创建字符串对象所需的内存分配次数从 `raw` 编码的两次降低为一次（一次分配一块连续的内存空间保存redisObject和SDS）；
    2. 释放 `embstr`编码的字符串对象同样只需要调用一次内存释放函数；
    3. 因为`embstr`编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用 CPU 缓存提升性能。
    4. 缺点：如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，所以**embstr编码的字符串对象实际上是只读的**。

### 应用场景

1. 缓存对象：
    - 直接缓存整个对象的 JSON，命令例子： `SET user:1 '{"name":"xiaolin", "age":18}'`。
    - 采用将 key 进行分离为 user:ID:属性，采用 MSET 存储，用 MGET 获取各属性值，命令例子： `MSET user:1:name xiaolin user:1:age 18 user:2:name xiaomei user:2:age 20`。
2. 共享session信息。
3. 分布式锁。
    
    SET 命令有个 NX 参数可以实现「key不存在才插入」，可以用它来实现分布式锁：
    
    - 如果 key 不存在，则显示插入成功，可以用来表示加锁成功；
    - 如果 key 存在，则会显示插入失败，可以用来表示加锁失败。
    
    ```java
    SET lock_key unique_value NX PX 10000
    // PX 设置锁的过期时间
    // lock_key 锁的id
    // unique_value 客户端标识
    ```
    

## 基本-List

List 列表是简单的字符串列表，**按照插入顺序排序**，可以从头部或尾部向 List 列表添加元素。

### 数据结构

1. **List底层的数据结构是什么？**双向链表或压缩列表。3.2版本后List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表。
2. **压缩列表是什么？**列表中的节点大小由节点数据的实际数据类型来决定，在数据前面用几个字节来记录节点的数据类型和大小。压缩列表内存布局紧凑，节省开销，但是存在连锁更新的问题，导致压缩列表占用的内存空间多次分配。而quicklist结合了链表和压缩列表，每一个链表结点指向一个更小的压缩列表，规避潜在的连锁更新风险。

### 应用场景

实现消息队列，List可以满足消息队列的三个需求：**消息保序**、**处理重复的消息**和**保证消息的可靠性**。但是不支持多个消费者消费同一条消息。

1. 消息保序：
    1. List 本身就是按先进先出的顺序对数据进行存取的，可以生产者用`LPUSH key value`插入消息，消费者用`RPOP key` 依次读取队列的消息；
    2. Redis提供了 `BRPOP` 命令解决消息者需要循环`RPOP` 导致性能消耗的问题。客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据。
2. 处理重复的消息：
    1. 每个消息都有一个全局的 ID，消费者要记录已经处理过的消息的 ID。如果消息已经处理，消费者程序就不会再进行处理了；
    2. List 并不会为每个消息生成 ID 号，所以我们需要自行为每个消息生成一个全局唯一ID，插入到消息中；
3. 保证消息的可靠性：
    
    List 类型提供了 `BRPOPLPUSH` 命令，这个命令的作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存。
    

## 基本-Hash

Hash 是一个键值对（key - value）集合，其中 value 的形式如： `value=[{field1，value1}，...{fieldN，valueN}]`。Hash 特别适合用于存储对象。

### 数据结构

1. **Hash底层的数据结构是什么？**
    
    Hash 类型的底层数据结构是由压缩列表或哈希表实现的，在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。
    
    - 如果哈希类型元素个数小于 `512` 个（默认值，可由 `hash-max-ziplist-entries` 配置），所有值小于 `64` 字节（默认值，可由 `hash-max-ziplist-value` 配置）的话，Redis 会使用**压缩列表**作为 Hash 类型的底层数据结构；
    - 如果哈希类型元素不满足上面条件，Redis 会使用**哈希表**作为 Hash 类型的 底层数据结构。

### 应用场景

1. 缓存对象，一般对象用 String + Json 存储，对象中某些频繁变化的属性可以考虑抽出来用 Hash 类型存储。
2. 实现购物车：
    - 添加商品：`HSET cart:{用户id} {商品id} 1`
    - 添加数量：`HINCRBY cart:{用户id} {商品id} 1`
    - 商品总数：`HLEN cart:{用户id}`
    - 删除商品：`HDEL cart:{用户id} {商品id}`
    - 获取购物车所有商品：`HGETALL cart:{用户id}`

## 基本-Set

无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。

### 数据结构

Set 类型的底层数据结构是由**哈希表或整数集合**实现的：

- 如果集合中的元素都是整数且元素个数小于 `512` （默认值，`set-maxintset-entries`配置）个，Redis 会使用**整数集合**作为 Set 类型的底层数据结构；
- 如果集合中的元素不满足上面条件，则 Redis 使用**哈希表**作为 Set 类型的底层数据结构。

### 应用场景

1. 点赞：可以确保一个用户只能对一篇文章点一个赞；
2. 共同关注：计算共同关注的好友、公众号等。

## 基本-Zset

相比于 Set 类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是排序值。

### 数据结构

Zset 类型的底层数据结构是由**压缩列表或跳表**实现的：

- 如果有序集合的元素个数小于 `128` 个，并且每个元素的值小于 `64` 字节时，Redis 会使用**压缩列表**作为 Zset 类型的底层数据结构；
- 如果有序集合的元素不满足上面的条件，Redis 会使用**跳表**作为 Zset 类型的底层数据结构；

**在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。**

### 应用场景

排行榜

# 线程模型

### Redis是单线程的吗？

Redis单线程是指**接收客户端请求->解析请求 ->进行数据读写等操作->发送数据给客户端**的过程由一个线程（主线程）来完成的。实际上，Redis在启动时会启动后台线程，处理：

- AOF刷盘；
- 关闭文件；
- 释放内存（lazyfree线程）。

这些任务都是很耗时的，交给后台线程以防主线程阻塞。

### 为什么Redis采用单线程还很快？

- Redis大部分操作都在内存中完成，并且采用了高效的数据结构。因此Redis的主要瓶颈是网络带宽。
- Redis用单线程避免了多线程之间的竞争，省去了线程切换带来的时间和性能上的开销，也不会有死锁问题。
- Redis采用了I/O多路复用的机制（一个线程处理多个IO流）处理大量的客户端Socket请求。

# 持久化

## AOF日志

### 什么是AOF？

将写操作记录到日志文件中，可以据此恢复。默认不开启。

### AOF记录日志和数据的顺序？

先执行写操作命令，再记录日志，都由主线程完成。

- 优点：
    1. 避免额外检查的开销：先记录日志就要保证命令语法正确，否则恢复数据时会出错；
    2. 不会阻塞当前写操作命令的执行。
- 缺点：
    1. 有数据丢失的风险；
    2. 有阻塞下一个命令的风险。

### AOF日志刷盘时机？

Redis提供了三种：

- Always：每次写操作命令执行完后，同步将AOF日志数据写回硬盘。
- Everysec：每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘。
- No：不由Redis决定写回硬盘的时机，交给操作系统决定。

Always最大程度保证数据不丢失，但会影响主进程性能；No数据丢失风险大；EverySec是一种折中的方式。

### AOF重写机制/AOF文件越来越大怎么办？

- 当AOF文件大小超过某个阈值之后，就会使用重写机制，读取当前数据库最新的键值对，将每一个键值对用一条命令记录到新的AOF文件。重写后用新的文件替换现有的AOF文件。
- AOF日志记录由主线程完成，重写由后台子进程完成。多线程会共享内存资源，如果加锁降低性能。而父子进程之间以只读方式共享内存（复制页表，指向同一片物理内存），如果任意一方修改了共享内存，就会发生写时复制（在发生写操作时，操作系统复制物理内存），父子进程有独立的数据副本。
- 在重写期间，主进程除了执行客户端的命令，还会把写命令追加到AOF缓冲区和AOF重写缓冲区。当子进程完成重写，会向主进程发送信号，主进程接受信号后，将重写缓冲区的内容追加到AOF文件中，并用新的文件替换旧文件。

## RDB快照

### 什么是RDB？

- RDB是全量快照，每次执行都会把内存中的所有数据记录到磁盘中。因此，如果操作频繁就会对Redis的性能产生影响。如果频率太低可能会丢失太多数据。
- 在bgsave快照过程中，主线程对内存的修改是无法被快照的。

### 执行快照的命令？

Redis提供两种：

- save：在主线程中生成RDB文件，如果写入RDB文件时间太长，就会阻塞主线程；
- bgsave：创建一个子进程来生成RDB文件，避免主线程的阻塞。

## AOF+RDB混合

混合使用AOF和RDB。在AOF重写日志时，首先会将与主线程共享的内存数据以RDB的形式写到AOF文件中，然后主线程处理的操作命令会被记录在重写缓冲区里，最后以增量形式写到AOF文件中。

- 加载数据时很快，AOF文件前半部分是RDB；
- 丢失的数据更少，快照期间主线程处理的命令会以AOF形式保存下来。

# 事务

## redis支持事务吗？

```bash
# 开启事务
multi

# 接下来的事务不会执行，而是加入队列中
...

# 提交事务
exec

# 取消事务
discard
```

1. redis支持事务，通过事务队列来实现。
2. redis的事务是弱事务：
    1. 当出现编译时错误，事务报错；
    2. 当出现运行时错误，不会中断也不会回滚，只有出错的操作不会执行。

# 过期删除策略

### 如何设置key过期的时间？

```jsx
expire <key> <n> # 单位秒
pexpire <key> <n> # 单位毫秒

set <key> <value> ex <n>
set <key> <value> px <n>
```

### 如何判定key已过期？

关键字和过期时间存放在过期字典中，该字典key指向键对象，value保存了key的过期时间。当访问某个键时，首先检查该键是否在过期字典中：

- 如果不在，则正常读取键值；
- 如果存在，则将过期时间与当前系统时间对比，如果比系统时间大就没有过期，否则判定该key已经过期。

### 过期删除策略有哪些？

1. **定时删除**：设置key的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行key的删除操作。过期key会尽快删除，对内存友好，但是如果key较多会占用相当一部分CPU，影响服务器的响应时间和吞吐。
2. **惰性删除**：不主动删除过期键，每次从数据库访问都检测key是否过期，如果过期再删除该key。对CPU时间最友好，但会造成内存空间的浪费。
3. **定期删除**：每隔一段时间随机从数据库中取出一定数量的key进行检查，并删除其中的过期key。难以确定删除的时长和频率。

### Redis使用的过期删除策略是什么？

Redis选择“**惰性删除**+**定期删除**”两种策略。

- 惰性删除：可以选择同步删除或异步删除。
- 定期删除：默认每秒钟10次，随机抽取20个key检查，如果过期key数量超过25%（5个），则重复抽取20个循环，否则等待下一轮。为了防止循环过度卡死，默认每一轮删除不会超过25ms。

### 主从模式下过期的键怎么处理？

- 从库不会过期扫描，即使key过期也可以得到value值。
- 主库在key到期时，会在AOF文件里增加一条del指令，同步到所有的从库。

### 持久化时对过期的键怎么处理？

1. RDB文件分两个阶段：
    1. 文件生成阶段：会检查所有的key，如果过期不会保存到新的AOF文件中。
    2. 加载阶段：主服务器会检查，过期的键不会载入数据库中，从库不会。但主从同步数据时从库会被清空，所以一般不会有什么影响。
2. AOF文件分两个阶段：
    1. 文件写入阶段：在键被删除后向AOF文件追加del命令。
    2. 文件重写阶段：重写时会对redis中的键值对进行检查，已过期的键不会被保存到重写后的AOF中。

# 内存淘汰策略

### Redis内存满了会发生什么？

运行内存到达某个阈值，会触发内存淘汰机制。

### Redis内存淘汰的策略有哪些？

![内存淘汰策略.webp](Redis%20e0cc3f2df5c64e759617b36b0b9cf454/%25E5%2586%2585%25E5%25AD%2598%25E6%25B7%2598%25E6%25B1%25B0%25E7%25AD%2596%25E7%2595%25A5.webp)

### LRU和LFU算法有什么区别？

- LRU（Least Recently Used）最近最少使用，会淘汰最近最少使用的数据。
    - 传统的LRU需要有额外的数据结构管理，带来额外的空间开销，且大量数据访问时会频繁将链表移动到队头，会很耗时，降低缓存性能。
    - Redis为缓存的对象添加额外的字段记录最后一次访问的事件，内存淘汰时会随机选择5个淘汰最久没有的使用的那个。
- LFU（Least Frequently Used）最近最不常使用，根据数据访问的次数淘汰数据。
    - Redis为缓存的对象添加额外的字段记录访问的时间戳和频次。每次访问时根据上次访问的距离时长对频次进行衰减，再按照一定概率增加。

# 高可用性

## 主从复制

### 主从复制的优点？

- 读写分离：主写从读，提高服务器的负载能力；
- 负载均衡：由多个slave分担master负载，提高Redis服务器并发量与数据吞吐量；
- 故障恢复：当主服务器出现问题时，由slave提供服务，实现快速故障恢复；
- 数据冗余：实现数据热备份；

### 主从复制的过程？

1. Slave服务器连接Master，发送SYNC命令，请求初始化同步；
2. Master收到SYNC后，通过BGSAVE命令生成RDB文件，并缓存该时段内的写命令；
3. Master完成RDB文件后，将其发送给所有Slave服务器；
4. Slave收到RDB文件后，删除内存中旧的缓存数据，装载RDB文件；
5. Master发送完RDB后，向所有Slave服务器发送缓存中的写命令。

## 哨兵模式

### 哨兵模式是什么？

当主库挂了，涉及到以下问题：

1. 主库真的挂了吗？
2. 该选择哪个从库作为主库？
3. 怎么把主库相关的信息通知给从库和客户端？

通过哨兵机制可以有效解决主从复制下故障转移的这三个问题。

哨兵（sentinel）是一个分布式系统，用于对主从结构中的每台服务器进行监控，当出现故障时通过投票机制选择新的master并将所有的slave连接到新的master。

- 哨兵是redis服务器，但**不提供数据服务**；
- 通常哨兵服务器为集群，数量通常为单数。
    - 如果使用单节点哨兵，哨兵实例在运行时发生故障，主从库无法正常切换；
    - 防止单节点哨兵误判主节点故障。

### 哨兵有什么作用？

- 监控：通过ping-pong机制不断检查主从服务器是否运作正常；
- 提醒：当服务器出现问题，可以通过API向管理员或其他应用程序发送通知；
- 自动故障转移：当一个主服务器不能正常工作，会自动进行故障迁移。

### 如何判断主库是否下线？

- 主观下线：
    - 如果主库或从库对ping命令的回应超时了，哨兵就会把它标记为“主观下线”。
    - 如果主观下线的是主库，不能直接开启主从切换，因为可能由于网络拥塞、主库压力大等情况造成哨兵误判。
- 客观下线：
    - 多个哨兵实例对同一个服务器做出下线判断，哨兵之间可以通过`SENTINEL is-master-down-by-addr`命令交流。
    - 客观下线条件只适用于主服务器。
    - 客观下线的确认数量由`qurum`确定，一般是哨兵集群个数的一半+1，当任务主观下线的哨兵个数达到该数量，就会进行一次投票。

### 如何选择新的Master节点？

1. **Slave的优先级**：可以手动设置slave的优先级，优先级高的直接成为Master。
2. **复制进度**：选出数据最完整的slave作为新的Master。
3. **runid**：优先级和复制进度都一样就选择运行ID最小的slave作为master，每个节点启动时会有一个随机字符串作为运行ID。

### 什么是集群脑裂？会有什么问题？

- 由于网络原因，主节点与其他节点失去联系，哨兵节点推举新的主节点，产生两个主节点。
- 网络恢复以后，旧的主节点将为从节点，清空数据并向新的主节点请求数据，导致之前客户端写入的数据丢失了。

### 怎么解决集群脑裂的问题？

- 设置主节点连接的从节点数小于某个阈值时禁止写入数据；
- 设置主节点主从复制和同步的延迟超过某个阈值时禁止写入数据。

## 分片集群

为了解决**海量数据的存储**以及**高并发写**的问题。

### 数据切片方案？

![Untitled](Redis%20e0cc3f2df5c64e759617b36b0b9cf454/Untitled.png)

- Redis Cluster采用无中心化的方案，采用哈希槽（Hash Slot）来处理数据和实例之间的映射关系。一个切片集群有16384个哈希槽，只给master分配。在创建集群时，需要把这些槽全部分配完，否则集群无法工作。具体的映射过程：
    - 根据键值对的key，按照CRC16算法计算一个16bit的值；
    - 再用16bit的值对16384进行取模，每个模数代表一个响应编号的哈希槽。
- 客户端与集群建立连接后，Redis实例会把哈希槽分配的信息发送给客户端，客户端将哈希槽信息缓存在本地。但实例和哈希槽的关系并不是一成不变的。实例之间可以相互传递消息获得最新的哈希槽分配信息，客户端无法感知这种变化。如果实例上没有该键值对映射的哈希槽，就会返回MOVED命令，客户端更新本地缓存。在迁移部分完成的情况下，会返回ASK，表明数据在迁移，ASK会把数据的最新实例地址返回给客户端，但是并不会更新客户端缓存的哈希槽分配的信息。

# Redis应用

## 延迟队列

延迟队列是把要做的事情往后推迟一段时间再做，例如订单超时未付款会自动取消。

可以使用有序集合ZSet来实现延迟消息队列，Zset有一个score属性可以用来存储延时执行的时间。通过zadd可以一直往内存中生产消息，再利用zrangebyscore可以查询符合条件的所有待处理的任务。

## 分布式锁

### 用Redis和实现分布式锁？

分布式锁用于控制某个资源在同一时刻只能被一个应用所使用。

Redis的Set命令有一个NX参数可以实现key不存在才插入，可以实现分布锁：

- 如果key不存在，则显示插入成功，表示加锁成功；
- 如果key存在，则显示插入失败，表示加锁失败。

```jsx
SET lock_key unique_value NX PX 10000

# unique_value用于表示客户端
# PX设置过期时间，防止客户端出现异常锁一直无法释放
```

### 基于Redis的分布式锁有什么优缺点？

1. 优点：性能高效、实现简单，避免单点故障（Redis集群）。
2. 缺点：
    1. 过期时间不好设置。设置过长影响性能，设置过短可能起不到保护的作用。可以启动一个守护线程，在一段时间后重新设置这个锁的超时时间。
    2. 主从复制是异步进行的，导致锁不可靠。如从主节点获取锁后没同步到其他节点，Redis主节点就宕机了。新的主节点依然可以获取锁。

## 大Key

### 什么是大key？

大key指key对应的value很大：

- String类型的值大于10KB；
- Hash、List、Set、ZSet类型的元素个数超过5000个。

### 大key会有什么问题？

- 客户端超时阻塞。Redis单线程，操作大key会比较耗时。
- 引发网络拥塞。获取大key产生的网络流量比比较大。
- 阻塞工作线程。del删除大key时阻塞工作线程。
- 内存分布不均。

### 怎么查询大key？

通过Redis内置的命令或者第三方解析RDB文件的工具。

### 如何删除大key？

应用程序释放内存时，操作系统会将释放掉的内存插入一个空闲内存块的链表，以便后续进行管理和分配。如过一次释放了大量的内存，空闲内存块链表操作时间会增加，造成主线程阻塞。

1. 分批次删除：每次查询前X个元素再删除。
2. 异步删除：将key放到一个异步线程中删除。