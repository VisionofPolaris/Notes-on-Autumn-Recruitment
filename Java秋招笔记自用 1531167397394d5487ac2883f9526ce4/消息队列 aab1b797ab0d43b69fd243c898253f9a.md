# 消息队列

# 基础概念

## 基础概念

### 什么是消息队列？

消息队列就是一个使用队列来通信的组件，即一种存放消息的容器，按照先进先出的顺序来消费。

### 消息队列的好处？

1. 异步处理提高系统性能，减少系统响应所需时间；
2. 削峰/限流：先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉；
3. 降低系统的耦合性，消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合。

### 消息队列的缺点？

1. 系统的可用性降低：要考虑MQ或者消息挂掉的情况；
2. 系统的复杂度提升：加入MQ要考虑消息的可靠性等情况。

## 消息队列选型

- **Kafka**：追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务，大型公司建议可以选用，如果有日志采集功能，肯定是首选 kafka。
- **RocketMQ**：天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。
- **RabbitMQ**：结合 erlang 语言本身的并发优势，性能较好，社区活跃度也比较高，但是不利于做二次开发和维护，不过 RabbitMQ 的社区十分活跃，可以解决开发过程中遇到的 bug。如果你的数据量没有那么大，小公司优先选择功能比较完备的 RabbitMQ。

# RabbitMQ

## 基础概念

### 什么是RabbitMQ？

RabbitMQ 是一个在 AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。

## 消息可靠性

### 消息丢失的原因？

消息从生产者发送到消费者接收，会经历多个过程，其中的每一步都可能导致消息丢失，常见的丢失原因包括：

- 发送时丢失：
    - 生产者发送的消息未送达exchange
    - 消息到达exchange后未到达queue
- consumer接收到消息后未消费就宕机
- MQ宕机，queue将消息丢失

### 如何确保RabbitMQ消息的可靠性？

1. **生产者确认机制**：可以确保消息能够抵达指定的队列，如果返还了消息可以重新投递进行补偿。
    1. 消息确认，为`RabbitTemplate`设置`ConfirmCallback` ，MQ返回结果时回调该方法，参数`ack==true`代表成功投递到交换机。
    2. 消息返还，为`RabbitTemplate`设置`ReturnCallback` ，MQ消息路由失败时调用该方法。
2. **MQ持久化**：消息持久化到硬盘，SpringAMQP都是默认持久化的。
    1. 交换机持久化：`new DirectExchange("simple.direct", true, false)` ，三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除。
    2. 队列持久化：`new Queue("simple.queue",true)` ，第二个参数durable。
    3. 消息持久化：`message.getMessageProperties() .setDeliveryMode(MessageDeliveryMode.PERSISTENT)` 。
3. **消费者确认机制**：RabbitMQ是通过消费者回执来确认消费者是否成功处理消息的：消费者获取消息后，应该向RabbitMQ发送ACK回执，表明自己已经处理消息。SpringAMQP则允许配置三种确认模式：
    - manual：手动ack，需要在业务代码结束后，调用api发送ack。
    - auto：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack
    - none：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除
4. **失败重试机制**：设置消费者确认机制`auto`后会无限重试，可以开启本地重试（最大重试次数、重试时间间隔、间隔时间倍数以及是否有状态（配合事务））以及达到最大重试次数之后的失败策略：
    - RejectAndDontRequeueRecoverer：重试耗尽后，直接reject，丢弃消息，默认就是这种方式
    - ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队
    - RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机，专门存放异常消息，最后由人工集中处理

## 死信交换机

### 什么是死信？

当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：

- 消费者使用basic.reject或 basic.nack声明消费失败，并且消息的requeue参数设置为false
- 消息是一个过期消息，超时无人消费
- 要投递的队列消息满了，无法投递

如果这个包含死信的队列配置了`dead-letter-exchange`属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为**死信交换机**（Dead Letter Exchange，检查DLX）。可以利用死信交换机收集所有消费者处理失败的消息（死信），交由人工处理，进一步提高消息队列的可靠性。

### 如何实现发送一个消息20秒后消费者才收到消息？

- 给消息的目标队列指定死信交换机
- 将消费者监听的队列绑定到死信交换机
- 发送消息时给消息设置超时时间（TTL）为20秒（也可以给队列设置TTL）

```java
// 给队列设置TTL
@Bean
public Queue ttlQueue(){
    return QueueBuilder.durable("ttl.queue") // 指定队列名称，并持久化
        .ttl(10000) // 设置队列的超时时间，10秒
        .deadLetterExchange("dl.ttl.direct") // 指定死信交换机
        .build();
}

// 给消息设置TTL
Message message = MessageBuilder
        .withBody("hello, ttl message".getBytes(StandardCharsets.UTF_8))
        .setExpiration("5000")
        .build();
```

还可以通过rabbitMQ的插件，设置延时交换机，并给消息设置x-delay头，设置超时时间。延时交换机会把消息先持久化到硬盘，到时间投递到队列。

## 惰性队列

### 什么是消息堆积问题？

生产者发送消息的速度超过了消费者处理消息的速度，导致队列中数据堆积。如果队列存储达到上限，最早接收到的消息会成为死信被丢弃。

解决思路：

- 增加更多的消费者，提高消费速度
- 在消费者内开启线程池，加快消息处理速度
- 扩大队列容积，提高堆积上限（惰性队列）

### 什么是惰性队列？

- 接受到消息之后直接存入磁盘而非内存
- 消费者要消费消息时才会从磁盘读取并加载到内存

优点：

- 支持数百万条的消息存储，消息上限高
- 没有间歇性page-out，性能比较稳定

缺点：

- 基于磁盘存储，消息的时效性会降低
- 性能受限于磁盘IO

## 集群

ErLang面向并发的语言，天然支持集群。

### RabbitMQ的集群有哪几种模式？

- **普通集群**：是一种分布式集群，将队列分散到集群的各个节点，从而提高整个集群的并发能力。
- **镜像集群**：是一种主从集群，普通集群的基础上，添加了主从备份功能，提高集群的数据可用性。

镜像集群虽然支持主从，但主从同步并不是强一致的，某些情况下可能有数据丢失的风险。因此在RabbitMQ的3.8版本以后，推出了新的功能：**仲裁队列**来代替镜像集群，底层采用Raft协议确保主从的数据一致性。

### 介绍一下普通集群？

普通集群，或者叫标准集群（classic cluster），具备下列特征：

- 会在集群的各个节点间共享部分数据，包括：交换机、队列元信息。不包含队列中的消息。
- 当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回
- 队列所在节点宕机，队列中的消息就会丢失

### 介绍一下镜像集群？

- 交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份。
- 创建队列的节点被称为该队列的**主节点，备份到的其它节点叫做该队列的镜像**节点。
- 一个队列的主节点可能是另一个队列的镜像节点
- 所有操作都是主节点完成，然后同步给镜像节点
- 主宕机后，镜像节点会替代成新的主节点