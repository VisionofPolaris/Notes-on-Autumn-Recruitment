# 版本管理器

# 理论基础

## 主要功能

数据库并发事务之间会造成两种冲突：

- 两个不同事务的读写冲突；
- 两个不同事务的写写冲突。

版本管理的一个很重要的职责就是实现调度序列的可串行化，通过**两段锁协议（2PL）**和多版本**并发控制（MVCC）**来实现。两阶段锁协议可以保证序列调度的可串行化，但是会导致事务之间相互阻塞，甚至可能导致死锁，通过MVCC可以提高事务处理的效率，降低阻塞概率。通过2PL和MVCC可以实现**读已提交**和**可重复读**两种隔离级别。不支持读未提交会出现级联回滚的情况，可能会导致已经提交的事务也需要回滚，这与commit的语义有冲突。

## 两段锁协议

### 基本概念

为了保证并发调度的正确性，提供两段锁协议来保证调度的可串行化，遵循两段锁协议是可串行化调度的充分条件，而不是必要条件。

两段锁协议指：所有的事务分为两个阶段对数据项加锁和解锁：

- 拓展阶段：在对数据的读、写之前，首先要申请并获得对该数据的锁；
- 收缩阶段：在释放一个锁之后，事务不再申请和获得任何其他的锁，严格的两阶段锁协议（Strict 2PL）只在事务提交或取消的时候释放锁。

基于两阶段所协议，有以下三种封锁协议：

- 一级封锁协议：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。事务结束包括正常结束(COMMIT)和非正常结束(ROLLBACK)。由于读数据是没有锁的，所以会读到脏数据，不能解决脏读和不可重复读的问题。
- 二级封锁协议：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后方可释放S锁。由于读完数据后即可释放S锁，所以它不能解决不可重复读。
- 三级封锁协议：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。可以解决脏读和不可重复读的问题。

### 死锁检测

两阶段锁会导致死锁，例如：

```
T1 begin;
T2 begin;
T1 W(U1); // T1获得了U1的锁
T2 W(U2); // T2获得了U2的锁
T1 W(U2); // T1阻塞
T2 W(U1); // T2阻塞，发生死锁
```

因此，在资源分配的时候需要首先进行死锁的检测，如果发生了死锁需要进行事务回滚。

用一个有向图结构维护资源分配关系，每一个节点代表事务或者资源（数据记录），用事务→资源代表请求等待关系，用资源→事务代表资源的占有关系。用DFS算法检测有向图是否有环：为每一个节点记录一个状态：例如，0代表未被访问，1代表正在被访问，2代表已经访问，每次选择一个没有被访问的节点作为根节点，开始深度优先遍历，被访问到的节点设置状态为1，如果在遍历过程中遇到了状态已经为1的节点，则证明图中有环。

```
// 伪代码
def dfs(node):
		// 结束条件
		if state[Node] == 1:
				return true;
		
		// 递归体
		state[subNode] = 1; // 访问当前节点
		for subNode in node相连的节点列表:
				if dfs(subNode) == true:
						return true;
		state[subNode] = 2; // 当前节点访问结束
		
		return false;
```

## 多版本并发控制

MVCC通过ReadView来实现对记录可见性的判断，根据隔离级别的不同，生成RV的时机也不同。

- MVCC可以避免读写冲突**。**事务在读取数据时，看到的是以前某一时刻数据的快照版本，其他事务对数据的修改，对于该事务是不可见的。（快照读）
- MVCC不一定可以避免写写冲突。当事务要写数据时，需要获得该条记录的最新版本，如果该条记录被其他事务修改就会造成冲突，如果其他事务没有提交就会读到脏数据。（当前读）

因此，对于强隔离性的操作（写操作）需要排他锁来确保数据的一致性。

# 设计与实现

## 数据结构

### Entry

Entry存放了DataItem的引用，是DataItem在VM层的抽象，将数据进一步划分为了三个部分：

- Xmin：创建条目的事务ID；
- Xmax：删除条目的事务ID；
- Data：实际的数据。

其中，Xmin和Xmax用于版本控制，Entry提供了解析数据的功能，提供访问和修改各个部分的接口，也是VM中缓存的内容。

![image.png](%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%99%A8%2054a125728e1646ab90b1db7ecc37a954/image.png)

### LockTable

LockTable保存了一个资源分配图，当事务需要删除或更新资源（数据Entry）时：

- 如果资源没有被访问，则直接加入图中。
- 如果资源已经被访问，首先进行死锁的检测：
    - 如果发生死锁则事务自动回滚；
    - 如果不会发生死锁就需要等待其他事务释放资源。

用一个信号量Semaphore实现事务之间的同步。当事务需要等待时，返回一个permit为1且已经被获取的信号量，事务访问资源之前会被阻塞，直到其他事务释放资源后，同时选择一个等待该资源的事务释放其信号量。

```java
// 加入资源分配图中，如果返回null则直接获取资源，返回信号量等待同步
Semaphore semaphore = lockTable.add(xid, uid);
if (semaphore != null) {
    // 如果资源已经被占用，就会阻塞
    semaphore.acquire();
    semaphore.release();
}
// 访问资源
...
```

### ReadView

ReadView用于MVCC，相当于生成ReadView时当前数据的快照。

ReadView的结构如下：

![image.png](%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%99%A8%2054a125728e1646ab90b1db7ecc37a954/image%201.png)

- 如果某个Entry的创建ID小于XIDMin或者不处在activeXID中，则证明事务已经完成（提交或取消）；
- 如果某个Entry的创建ID大于等于XIDMax或者处在activeXID中，则证明事务尚未完成（活跃）；

可见性判断时，以下两种情况Entry对于事务可见：

1. 当前Entry的创建事务是自己且没有被删除则可见。
2. 当前Entry的创建事务已经被提交，且尚未删除或由一个未提交的事务删除。

## 事务隔离级别

VM模块只提供三种类型的操作：Read（快照读）、Delete（删除）、Insert（插入），Update操作可以由Delete和Insert组合完成。

### 读已提交

1. Select：生成新的ReadView，按可见性返回数据；
2. Delete：生成新的ReadView，如果数据可见，将数据和事务加入资源分配图中，如果能获得对资源的信号量，将数据Xmax设为当前事务ID；
3. Insert：创建新的数据Entry，Xmin设置为当前事务；
4. Update：将原数据删除（Delete），并插入（Insert）新的数据。

### 可重复读

在事务创建时创建一个ReadView并在事务期间保持不变。

1. Select：按可见性返回数据；
2. Delete：生成新的ReadView，如果删除数据可见，将数据和事务加入资源分配图中，如果能获得对资源的信号量，将数据Xmax设为当前事务ID；
    
    MySQL中，记录有版本链，删除和更新数据会拉取修改记录的最新数据，再读其他行时还是快照时的数据。本项目里无法得知哪些数据记录属于同一个版本链，如果更新完之后按快照时的数据来读还会读到修改之前的数据，导致错误。可以在Entry里加个指针，这样做要修改的代价太大了，遂跟读已提交类似，直接更新了ReadView。
    
3. Insert：创建新的数据Entry，Xmin设置为当前事务；
4. Update：将原数据删除（Delete），并插入（Insert）新的数据。

## 模块架构

同时展示了读已提交级别下删除数据的流程。

![image.png](%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%99%A8%2054a125728e1646ab90b1db7ecc37a954/image%202.png)

# 总结

版本管理（VM）主要解决数据库事务并发造成的读写和写写冲突，通过**两段锁协议**（Strict 2PL）以及**多版本并发控制**（MVCC）实现了**“读已提交”**和**“可重复读”**两种事务隔离级别。

两段锁协议是一个使用锁的规范标准，要求加锁和解锁分为两个阶段，在释放一个锁之后不能再获取任何其他锁。这种方法可以实现**事务调度的可串行化**，但是会造成事务阻塞、并发度低以及死锁的问题。

**针对并发度低的问题**，引入了MVCC。MVCC相当于**数据的快照**，通过ReadView记录了某一时刻那些事务已经完成，哪些事务没有完成。而在数据条目Entry中，也同样记录了创建的事务和删除的事务ID，结合ReadView和Entry可以判断哪些数据对于当前事务可见。

根据创建ReadView的时机，可以实现不同的事务隔离级别：针对读已提交，在**更新或删除数据时**为事务生成新的ReadView；针对可重复读，在**事务创建时**就生成ReadView，并且在事务的执行期间使用同一个ReadView。

**针对死锁的问题**，引入了资源分配图，将数据Entry视为资源，当事务所需的资源已经被占有时，通过**深度优先遍历算法**DFS检测有向图中是否有环来判断死锁，如果发生死锁自动进行事务的回滚。

此外，VM还统筹了事务管理模块（TM）和数据管理模块（DM），向上层提供了事务操作和数据操作的接口。